---
description: When working on a feature which changes the schema or the resolvers, make sure to adjust all parts correctly
alwaysApply: false
---

# Schema and Resolver Update Process

## Schema Synchronization

### Apollo Schema Updates (`packages/common/schema/apollo.schema.graphql`)

- **Add new types** with proper GraphQL syntax and relationships
- **Update existing types** by adding/removing fields and relationships
- **Add new enums** for status fields and type classifications
- **Update Query/Mutation/Subscription** operations with new fields and parameters
- **Maintain consistency** with DGraph schema structure and relationships

### DGraph Schema Updates (`packages/common/schema/dgraph.schema.graphql`)

- **Add @withSubscription** directive to new types for real-time updates
- **Add @search directives** for queryable fields (hash, exact, term, fulltext)
- **Add @hasInverse** directives for bidirectional relationships
- **Use DateTime scalar** instead of Date for DGraph compatibility
- **Maintain relationship consistency** with Apollo schema

### Schema Update Workflow

1. **Update both schemas** simultaneously to maintain consistency
2. **Run codegen** at repository level: `npm run codegen`
3. **Verify generated types** in `packages/common/src/graphql/`
4. **Update resolvers** to match new schema structure
5. **Update repositories** using backend-data-manipulation patterns

## Resolver Updates (`packages/backend/src/database/resolvers.ts`)

### Resolver Integration Patterns

- **Add new Query resolvers** for new entity types
- **Add new Mutation resolvers** for create/update/delete operations
- **Add new Subscription resolvers** for real-time updates
- **Use repository pattern** from backend-data-manipulation rule
- **Maintain type safety** with generated types from `@2ly/common`

### Resolver Structure

```typescript
export const resolvers = (): apolloResolversTypes.Resolvers => {
  const entityRepository = container.get(EntityRepository);

  return {
    Query: {
      newEntity: async () => entityRepository.findAll(),
    },
    Mutation: {
      createNewEntity: async (_parent, args) => entityRepository.create(...args),
      updateNewEntity: async (_parent, args) => entityRepository.update(args.id, ...args),
      deleteNewEntity: async (_parent, { id }) => entityRepository.delete(id),
    },
    Subscription: {
      newEntityUpdates: {
        subscribe: () => entityRepository.observeEntity(),
      },
    },
  };
};
```

## Repository Updates

### Repository Creation Pattern

- **Create repository class** in `packages/backend/src/repositories/`
- **Create operations file** with GraphQL operations
- **Implement CRUD methods** following backend-data-manipulation patterns
- **Add observable methods** for real-time updates
- **Register in DI container** in `packages/backend/src/di/container.ts`

### Repository Method Patterns

```typescript
// Standard CRUD methods
async findAll(): Promise<NewEntity[]>
async create(...params): Promise<NewEntity>
async update(id: string, ...params): Promise<NewEntity>
async delete(id: string): Promise<NewEntity>

// Observable methods for subscriptions
observeNewEntity(): Observable<NewEntity[]>
```

## Frontend Integration

### GraphQL Operations

- **Add new queries** in `packages/frontend/src/graphql/queries.ts`
- **Add new mutations** in `packages/frontend/src/graphql/mutations.ts`
- **Add new subscriptions** in `packages/frontend/src/graphql/subscriptions.ts`
- **Use generated types** from `@2ly/common` for type safety

### Component Updates

- **Update existing components** to use new schema fields
- **Add new components** for new entity types
- **Update forms** to handle new input fields
- **Update lists/tables** to display new fields
- **Add real-time updates** using subscriptions where appropriate

## Code Generation Process

### Codegen Execution

- **Run at repository level**: `npm run codegen`
- **Generates types** for both Apollo and DGraph schemas
- **Updates resolver types** in `packages/common/src/graphql/`
- **Creates type-safe** interfaces for all operations

### Generated Files Location

- **Apollo types**: `packages/common/src/graphql/apollo.resolvers.types.ts`
- **DGraph types**: `packages/common/src/graphql/dgraph.resolvers.types.ts`
- **Shared types**: `packages/common/src/types/`

## Complete Update Workflow

### Step-by-Step Process

1. **Update Apollo schema** (`packages/common/schema/apollo.schema.graphql`)
2. **Update DGraph schema** (`packages/common/schema/dgraph.schema.graphql`)
3. **Run codegen**: `npm run codegen`
4. **Create/update repository** following backend-data-manipulation patterns
5. **Update resolvers** in `packages/backend/src/database/resolvers.ts`
6. **Update frontend operations** (queries/mutations/subscriptions)
7. **Update frontend components** to use new schema
8. **Test complete flow** from frontend to backend

### Validation Checklist

- **Schema consistency** between Apollo and DGraph
- **Type safety** with generated types
- **Repository patterns** following backend-data-manipulation rule
- **Resolver integration** with proper error handling
- **Frontend integration** with proper TypeScript types
- **Real-time updates** working via subscriptions
- **CRUD operations** working end-to-end

## Error Handling

### Schema Validation

- **Check for syntax errors** in both schema files
- **Verify relationship consistency** between schemas
- **Ensure proper directives** in DGraph schema
- **Validate generated types** after codegen

### Resolver Validation

- **Test all CRUD operations** with new schema
- **Verify subscription functionality** for real-time updates
- **Check error handling** for invalid inputs
- **Validate type safety** throughout the stack

## Best Practices

### Schema Design

- **Keep schemas synchronized** between Apollo and DGraph
- **Use descriptive field names** that reveal intent
- **Add proper search directives** for queryable fields
- **Include all necessary relationships** in type definitions

### Resolver Design

- **Follow repository pattern** from backend-data-manipulation rule
- **Keep resolvers thin** and delegate to repositories
- **Use proper TypeScript types** from generated code
- **Handle errors gracefully** with domain-specific error types

### Frontend Integration

- **Use generated types** for all GraphQL operations
- **Implement proper loading states** for async operations
- **Add error boundaries** for GraphQL errors
- **Use subscriptions** for real-time data where appropriate
  description: When working on a feature which changes the schema or the resolvers, make sure to adjust all parts correctly
  alwaysApply: false

---
