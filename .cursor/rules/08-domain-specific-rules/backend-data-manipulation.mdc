---
globs: **/database/resolvers.ts,**/repositories/**/*.ts
alwaysApply: false
---

# Backend Data Manipulation Patterns

## Repository Architecture

### Repository Structure

- **Repository Classes**: Located in `packages/backend/src/repositories/`
- **Operations Files**: Private to repositories directory, contain GraphQL operations
- **Repository Interface**: Each repository exposes CRUD operations and observables
- **Dependency Injection**: All repositories use `@injectable()` decorator and are registered in DI container

### Repository Pattern Rules

- **Single Responsibility**: Each repository handles one domain entity
- **Naming Convention**: `{EntityName}Repository` for classes, `{entity-name}.repository.ts` for files
- **Operations Separation**: GraphQL operations stored in `{entity-name}.operations.ts` files
- **Export Strategy**: Only repository classes exported from `index.ts`, operations remain private

### Repository Method Patterns

```typescript
// Standard CRUD methods
async findAll(): Promise<Entity[]>
async create(...params): Promise<Entity>
async update(id: string, ...params): Promise<Entity>
async delete(id: string): Promise<Entity>

// Query methods with relationships
async findByIdWith{Relationship}(id: string): Promise<Entity>

// Observable methods for real-time updates
observe{Entity}(): Observable<Entity[]>
```

## GraphQL Operations Organization

### Operations File Structure

- **File Naming**: `{entity-name}.operations.ts`
- **Operation Naming**: UPPER_SNAKE_CASE with descriptive prefixes
- **Export Pattern**: Export all operations as named constants

### Operation Naming Conventions

```typescript
// Mutations
ADD_{ENTITY} = gql`mutation add{Entity}...`
UPDATE_{ENTITY} = gql`mutation update{Entity}...`
DELETE_{ENTITY} = gql`mutation delete{Entity}...`

// Queries
QUERY_{ENTITIES} = gql`query query{Entities}...`
QUERY_{ENTITY}_WITH_{RELATIONSHIP} = gql`query get{Entity}...`

// Dynamic operations (for query/subscription conversion)
QUERY_{ENTITY}_CAPABILITIES = (type: 'query' | 'subscription') => gql`...`
```

### Operation Structure Rules

- **Return Type**: Always return the full entity with all required fields
- **Input Validation**: Use GraphQL schema types for parameter validation
- **Relationship Loading**: Include nested relationships in return fields
- **Consistent Fields**: Maintain consistent field selection across operations

## Resolver Integration

### Resolver Pattern

- **Repository Injection**: Get repositories from DI container in resolver factory
- **Type Safety**: Use generated types from `@2ly/common`
- **Error Handling**: Let repository methods handle errors, resolvers focus on data flow

### Resolver Structure

```typescript
export const resolvers = (): apolloResolversTypes.Resolvers => {
  const repository = container.get(RepositoryClass);

  return {
    Query: {
      entity: async () => repository.findAll(),
    },
    Mutation: {
      createEntity: async (_parent, args) => repository.create(...args),
      updateEntity: async (_parent, args) => repository.update(args.id, ...args),
      deleteEntity: async (_parent, { id }) => repository.delete(id),
    },
    Subscription: {
      entityUpdates: {
        subscribe: () => repository.observeEntity(),
      },
    },
  };
};
```

### Resolver Method Patterns

- **Query Resolvers**: Simple delegation to repository methods
- **Mutation Resolvers**: Parameter destructuring and repository delegation
- **Subscription Resolvers**: Use `observableToAsyncGenerator` helper for RxJS conversion

## Subscription Creation

### Subscription Helper Usage

```typescript
import { createSubscriptionFromQuery } from '../helpers/gql';

// Convert query to subscription
const query = createSubscriptionFromQuery(QUERY_ENTITY);
const observable = dgraphService.observe(query, variables, 'fieldName', true);
```

### Subscription Pattern Rules

- **Query Conversion**: Use `createSubscriptionFromQuery()` to convert queries to subscriptions
- **Observable Mapping**: Use RxJS operators to transform subscription data
- **Field Extraction**: Map workspace-level subscriptions to entity arrays
- **Error Handling**: Handle subscription errors gracefully with fallback values

### Observable Method Patterns

```typescript
observe{Entity}(): Observable<Entity[]> {
  const query = createSubscriptionFromQuery(QUERY_ENTITY_WITH_RELATIONSHIP);
  return this.dgraphService
    .observe<Workspace>(query, { workspaceId }, 'getWorkspace', true)
    .pipe(map((workspace) => workspace.entities || []));
}
```

## Data Flow Architecture

### Request Flow

1. **GraphQL Request** → Resolver
2. **Resolver** → Repository Method
3. **Repository** → DGraphService (query/mutation/observe)
4. **DGraphService** → DGraph Database
5. **Response** → Repository → Resolver → Client

### Real-time Updates Flow

1. **Subscription Request** → Resolver
2. **Resolver** → Repository Observable Method
3. **Repository** → DGraphService.observe()
4. **DGraphService** → DGraph Subscription
5. **Updates** → Observable → AsyncGenerator → Client

## Best Practices

### Repository Design

- **Encapsulation**: Operations files remain private to repository directory
- **Type Safety**: Use generated types from codegen
- **Consistency**: Follow established patterns for all entities
- **Observables**: Provide real-time updates for all major entities

### Operation Design

- **Completeness**: Include all necessary fields in return types
- **Relationships**: Load nested relationships when needed
- **Flexibility**: Support both query and subscription modes where appropriate
- **Naming**: Use descriptive, consistent naming conventions

### Resolver Design

- **Simplicity**: Keep resolvers thin, delegate to repositories
- **Consistency**: Follow established patterns for all entity types
- **Type Safety**: Use proper TypeScript types throughout
- **Error Handling**: Let repositories handle domain-specific errors

### Subscription Design

- **Workspace Scoping**: Scope subscriptions to workspace when possible
- **Data Transformation**: Use RxJS operators for data transformation
- **Fallbacks**: Provide fallback values for missing relationships
- **Performance**: Only subscribe to necessary data

## Implementation Checklist

When implementing new backend operations:

1. **Repository Class**: Create `{Entity}Repository` with CRUD methods
2. **Operations File**: Create `{entity-name}.operations.ts` with GraphQL operations
3. **Repository Methods**: Implement standard CRUD + observable methods
4. **Resolver Integration**: Add to resolver factory with proper typing
5. **Subscription Support**: Add observable methods for real-time updates
6. **Type Safety**: Use generated types from `@2ly/common`
7. **Testing**: Ensure all operations work with both query and subscription modes
   description:
   globs:
   alwaysApply: false

---
