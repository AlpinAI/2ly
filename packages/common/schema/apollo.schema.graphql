scalar Date

enum ActiveStatus {
  ACTIVE
  INACTIVE
}

enum MCPTransportType {
  STREAM
  SSE
  STDIO
}

enum ExecutionTarget {
  AGENT
  EDGE
}

enum RuntimeType {
  EDGE
  MCP
}

type Infra {
  nats: String
  remoteMCP: String
}

type System {
  id: ID!
  initialized: Boolean!
  createdAt: Date!
  updatedAt: Date!
  runtimes: [Runtime!]
  defaultWorkspace: Workspace
}

type Workspace {
  id: ID!
  name: String!
  createdAt: Date!
  mcpServers: [MCPServer!]
  mcpTools: [MCPTool!]
  runtimes: [Runtime!]
  skills: [Skill!]
  agents: [Agent!]
  registryServers: [MCPRegistryServer!]
  onboardingSteps: [OnboardingStep!]
  aiProviders: [AIProviderConfig!]
  defaultAIModel: String
}

type MCPServer {
  id: ID!
  name: String!
  description: String!
  repositoryUrl: String!
  transport: MCPTransportType!
  config: String!
  tools: [MCPTool!]
  runOn: ExecutionTarget
  runtime: Runtime
  registryServer: MCPRegistryServer!
  workspace: Workspace!
}

type MCPTool {
  id: ID!
  name: String!
  description: String!
  inputSchema: String!
  annotations: String!
  status: ActiveStatus!
  createdAt: Date!
  lastSeenAt: Date!
  mcpServer: MCPServer!
  skills: [Skill!]
  workspace: Workspace!
}

type Skill {
  id: ID!
  name: String!
  description: String
  createdAt: Date!
  updatedAt: Date
  mcpTools: [MCPTool!]
  agents: [Agent!]
  workspace: Workspace!
  toolCalls: [ToolCall!]
}

type Agent {
  id: ID!
  name: String!
  description: String
  createdAt: Date!
  updatedAt: Date
  systemPrompt: String!
  model: String!
  temperature: Float!
  maxTokens: Int!
  skills: [Skill!]
  runOn: ExecutionTarget
  runtime: Runtime
  workspace: Workspace!
}

type IdentityKey {
  id: ID!
  key: String!
  description: String
  createdAt: Date!
  expiresAt: Date
  revokedAt: Date
  relatedId: String!
}

type Runtime {
  id: ID!
  name: String!
  description: String
  status: ActiveStatus!
  type: RuntimeType!
  createdAt: Date!
  lastSeenAt: Date
  roots: String
  mcpServers: [MCPServer!]
  agents: [Agent!]
  workspace: Workspace
  system: System
  hostIP: String
  hostname: String
  mcpClientName: String
  toolResponses: [ToolCall!]
}

enum OnboardingStepType {
  ONBOARDING
  ANNOUNCEMENT
  LEARNING
}

enum OnboardingStepStatus {
  PENDING
  COMPLETED
  DISMISSED
}

enum ToolCallStatus {
  PENDING
  COMPLETED
  FAILED
}

type OnboardingStep {
  id: ID!
  stepId: String!
  type: OnboardingStepType!
  status: OnboardingStepStatus!
  priority: Int
  metadata: String
  createdAt: Date!
  updatedAt: Date
}

type ToolCall {
  id: ID!
  toolInput: String!
  calledAt: Date!
  completedAt: Date
  status: ToolCallStatus!
  toolOutput: String
  error: String
  isTest: Boolean!
  executedByAgent: Boolean
  mcpTool: MCPTool!
  calledBy: Skill
  executedBy: Runtime
}

type User {
  id: ID!
  email: String!
  createdAt: Date!
  updatedAt: Date!
  lastLoginAt: Date
  adminOfWorkspaces: [Workspace!]
  membersOfWorkspaces: [Workspace!]
}

type AuthPayload {
  user: User!
  accessToken: String!
  refreshToken: String!
  expiresIn: Int!
}

type RefreshTokenPayload {
  accessToken: String!
  expiresIn: Int!
}

input LoginInput {
  email: String!
  password: String!
  deviceInfo: String
}

input RefreshTokenInput {
  refreshToken: String!
}

input LogoutInput {
  refreshToken: String!
}

type MCPRegistryServer {
  id: ID!
  name: String!
  description: String!
  title: String!
  repositoryUrl: String!
  version: String!
  packages: String
  remotes: String
  _meta: String
  createdAt: Date!
  lastSeenAt: Date!
  workspace: Workspace!
  configurations: [MCPServer!]
}

# AI Provider Configuration - BYOK (Bring Your Own Key) support
enum AIProviderType {
  OPENAI
  ANTHROPIC
  GOOGLE
  OLLAMA
}

type AIProviderConfig {
  id: ID!
  provider: AIProviderType!
  # Custom base URL - for Ollama or custom endpoints
  baseUrl: String
  # Cached list of available models
  availableModels: [String!]
  createdAt: Date!
  updatedAt: Date!
}

type AIProviderValidation {
  valid: Boolean!
  error: String
  availableModels: [String!]
}

type AIModel {
  id: String!
  name: String!
  contextWindow: Int
}

# Monitoring types for scalable tool call queries
input ToolCallFilters {
  status: [ToolCallStatus!]
  mcpToolIds: [ID!]
  mcpServerIds: [ID!]
  runtimeIds: [ID!]
  dateFrom: Date
  dateTo: Date
  search: String
}

enum OrderDirection {
  ASC
  DESC
}

type ToolCallsResult {
  toolCalls: [ToolCall!]!
  totalCount: Int!
  hasMore: Boolean!
  stats: ToolCallStats!
}

type ToolCallStats {
  total: Int!
  pending: Int!
  completed: Int!
  failed: Int!
  avgDuration: Float
}

type Query {
  workspaces: [Workspace!]!
  workspace(workspaceId: ID!): Workspace
  mcpServers(workspaceId: ID!): [MCPServer!]
  mcpTools(workspaceId: ID!): [MCPTool!]
  skills(workspaceId: ID!): [Skill!]
  system: System
  infra: Infra!
  workspaceMCPTools(workspaceId: ID!): Workspace
  getRegistryServers(workspaceId: ID!): [MCPRegistryServer!]!
  # Monitoring query with filtering and pagination
  toolCalls(
    workspaceId: ID!
    limit: Int
    offset: Int
    filters: ToolCallFilters
    orderDirection: OrderDirection
  ): ToolCallsResult!
  # Key management queries
  workspaceKeys(workspaceId: ID!): [IdentityKey!]!
  skillKey(skillId: ID!): IdentityKey
  keyValue(keyId: ID!): String!
  # Authentication queries
  me: User
  # AI Provider queries
  getAIProviders(workspaceId: ID!): [AIProviderConfig!]!
  getAIProvider(workspaceId: ID!, provider: AIProviderType!): AIProviderConfig
  # Get all available models from all configured providers (format: "provider/model")
  getAIModels(workspaceId: ID!): [String!]!
  # Agent queries
  getAgent(id: ID!): Agent
  getAgentsByWorkspace(workspaceId: ID!): [Agent!]!
}

type CallToolResult {
  success: Boolean!
  result: String!
}

type Mutation {
  createMCPServer(
    name: String!
    description: String!
    repositoryUrl: String!
    transport: MCPTransportType!
    config: String!
    runOn: ExecutionTarget
    workspaceId: ID!
    registryServerId: ID!
  ): MCPServer!
  updateMCPServer(
    id: ID!
    name: String!
    description: String!
    repositoryUrl: String!
    transport: MCPTransportType!
    config: String!
    runOn: ExecutionTarget
  ): MCPServer!
  linkMCPServerToRuntime(mcpServerId: ID!, runtimeId: ID!): MCPServer!
  unlinkMCPServerFromRuntime(mcpServerId: ID!): MCPServer!
  createRuntime(name: String!, description: String!, type: RuntimeType!, workspaceId: ID!): Runtime!
  updateRuntime(id: ID!, name: String!, description: String!): Runtime!
  deleteRuntime(id: ID!): Runtime!
  deleteMCPTool(id: ID!): MCPTool!
  deleteMCPServer(id: ID!): MCPServer!
  # Skill mutations
  createSkill(name: String!, description: String!, workspaceId: ID!): Skill!
  updateSkill(id: ID!, name: String!, description: String!): Skill!
  deleteSkill(id: ID!): Skill!
  addMCPToolToSkill(mcpToolId: ID!, skillId: ID!): Skill!
  removeMCPToolFromSkill(mcpToolId: ID!, skillId: ID!): Skill!
  initSystem(adminPassword: String!, email: String!): System!
  updateWorkspace(id: ID!, name: String!): Workspace!
  setGlobalRuntime(id: ID!, runtimeId: ID!): Workspace!
  unsetGlobalRuntime(id: ID!): Workspace!
  updateMCPServerRunOn(mcpServerId: ID!, runOn: ExecutionTarget!, runtimeId: ID): MCPServer!

  # Registry server mutations
  addServerToRegistry(
    workspaceId: ID!
    name: String!
    description: String!
    title: String!
    repositoryUrl: String!
    version: String!
    packages: String
    remotes: String
  ): MCPRegistryServer!
  updateServerInRegistry(
    serverId: ID!
    name: String
    description: String
    title: String
    repositoryUrl: String
    version: String
    packages: String
    remotes: String
  ): MCPRegistryServer!
  removeServerFromRegistry(serverId: ID!): MCPRegistryServer!

  # Playground mutations
  callMCPTool(toolId: ID!, input: String!): CallToolResult!

  # Onboarding mutations
  completeOnboardingStep(workspaceId: ID!, stepId: String!): Boolean!
  dismissOnboardingStep(workspaceId: ID!, stepId: String!): Boolean!

  # Key management mutations
  createWorkspaceKey(workspaceId: ID!, description: String!): IdentityKey!
  revokeKey(keyId: ID!): IdentityKey!

  # Authentication mutations
  registerUser(input: RegisterUserInput!): RegisterUserPayload!
  loginUser(input: LoginUserInput!): AuthPayload!
  login(input: LoginInput!): AuthPayload!
  refreshToken(input: RefreshTokenInput!): RefreshTokenPayload!
  logout(input: LogoutInput!): Boolean!
  logoutUser(input: LogoutUserInput!): LogoutPayload!

  configureAIProvider(
    workspaceId: ID!
    provider: AIProviderType!
    apiKey: String
    baseUrl: String
  ): AIProviderValidation!

  setDefaultAIModel(workspaceId: ID!, defaultModel: String!): Boolean!

  removeAIProvider(providerId: ID!): Boolean!

  # Chat with a specific model (format: "provider/model-name")
  chatWithModel(workspaceId: ID!, model: String!, message: String!): String!

  # Agent mutations
  createAgent(input: CreateAgentInput!): Agent!
  updateAgent(input: UpdateAgentInput!): Agent!
  deleteAgent(id: ID!): Agent!
  callAgent(agentId: ID!, userMessages: [String!]!): String!
  updateAgentRunOn(agentId: ID!, runOn: ExecutionTarget!, runtimeId: ID): Agent!
}

input CreateAgentInput {
  name: String!
  description: String
  systemPrompt: String!
  model: String!
  temperature: Float
  maxTokens: Int
  runOn: ExecutionTarget
  workspaceId: ID!
}

input UpdateAgentInput {
  id: ID!
  name: String
  description: String
  systemPrompt: String
  model: String
  temperature: Float
  maxTokens: Int
  runOn: ExecutionTarget
  runtimeId: ID
}

# Authentication types
type User {
  id: ID!
  email: String!
  createdAt: Date!
  lastLoginAt: Date
}

type AuthTokens {
  accessToken: String!
  refreshToken: String!
}

type AuthPayload {
  success: Boolean!
  user: User
  tokens: AuthTokens
  errors: [String!]
}

type RegisterUserPayload {
  success: Boolean!
  user: User
  tokens: AuthTokens
  errors: [String!]
}

type RefreshTokenPayload {
  success: Boolean!
  accessToken: String
  errors: [String!]
}

type LogoutPayload {
  success: Boolean!
  errors: [String!]
}

input RegisterUserInput {
  email: String!
  password: String!
  deviceInfo: String
}

input LoginUserInput {
  email: String!
  password: String!
  deviceInfo: String
}

input LoginInput {
  email: String!
  password: String!
  deviceInfo: String
}

input RefreshTokenInput {
  refreshToken: String!
}

input LogoutUserInput {
  refreshToken: String!
}

input LogoutInput {
  refreshToken: String!
}

type Subscription {
  workspaces: [Workspace!]
  workspace(workspaceId: ID!): Workspace
  runtimes(workspaceId: ID!): [Runtime!]
  mcpServers(workspaceId: ID!): [MCPServer!]
  mcpTools(workspaceId: ID!): [MCPTool!]
  skills(workspaceId: ID!): [Skill!]
  toolCalls(workspaceId: ID!): [ToolCall!]
}
