scalar DateTime

enum ActiveStatus {
  ACTIVE
  INACTIVE
}

enum MCPTransportType {
  STDIO
  SSE
  STREAM
}

enum MCPServerRunOn {
  GLOBAL
  AGENT
  EDGE
}

type System {
  id: ID!
  initialized: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  instanceId: String!
  workspaces: [Workspace!] @hasInverse(field: system)
  defaultWorkspace: Workspace
  admins: [User!]
}

type Workspace @withSubscription {
  id: ID!
  name: String! @search(by: [hash])
  createdAt: DateTime!
  mcpServers: [MCPServer!] @hasInverse(field: workspace)
  mcpTools: [MCPTool!] @hasInverse(field: workspace)
  runtimes: [Runtime!] @hasInverse(field: workspace)
  toolSets: [ToolSet!] @hasInverse(field: workspace)
  registryServers: [MCPRegistryServer!] @hasInverse(field: workspace)
  admins: [User!] @hasInverse(field: adminOfWorkspaces)
  users: [User!] @hasInverse(field: membersOfWorkspaces)
  system: System! @hasInverse(field: workspaces)
  globalRuntime: Runtime
  onboardingSteps: [OnboardingStep!]
  aiConfig: AIConfig
}

type MCPRegistryServer @withSubscription {
  id: ID!
  name: String! @search(by: [hash])
  description: String!
  title: String!
  repositoryUrl: String!
  version: String!
  packages: String!
  remotes: String
  _meta: String
  createdAt: DateTime!
  lastSeenAt: DateTime!
  workspace: Workspace! @hasInverse(field: registryServers)
  configurations: [MCPServer!] @hasInverse(field: registryServer)
}

type MCPServer @withSubscription {
  id: ID!
  name: String! @search(by: [hash])
  description: String!
  repositoryUrl: String!
  transport: MCPTransportType!
  # The `config` field contains THE SINGLE SELECTED configuration for this MCP server deployment.
  # It is NOT an array - it's the one chosen package or remote configuration.
  #
  # When transport is STDIO: config contains a single Package object following the
  # Package schema from the MCP registry (with identifier, packageArguments, runtimeArguments,
  # environmentVariables, etc.)
  #
  # When transport is SSE or STREAM: config contains a single Transport object following
  # the Transport schema from the MCP registry (with type, url, headers, etc.)
  # Note: SSE and STREAM both use the Transport schema, differentiated by the "type" field
  # ("sse" for SSE transport, "streamableHttp" for STREAM transport)
  #
  # The config values come from selecting ONE item from either MCPRegistryServer.packages
  # or MCPRegistryServer.remotes during the server configuration workflow.
  config: String!
  tools: [MCPTool!] @hasInverse(field: mcpServer)
  runOn: MCPServerRunOn @search
  # an MCP server can run either on a specific runtime - or if no value is provided it will be launch on the agent runtime which requires the capability
  runtime: Runtime @hasInverse(field: mcpServers)
  registryServer: MCPRegistryServer! @hasInverse(field: configurations)
  workspace: Workspace! @hasInverse(field: mcpServers)
}

type MCPTool @withSubscription {
  id: ID!
  name: String! @search(by: [hash])
  description: String!
  inputSchema: String!
  annotations: String!
  status: ActiveStatus! @search
  createdAt: DateTime!
  lastSeenAt: DateTime!
  mcpServer: MCPServer! @hasInverse(field: tools)
  # Relationship to Runtimes: represents which runtimes can EXECUTE this tool
  # This is about runtime execution capability, not logical grouping
  runtimes: [Runtime!] @hasInverse(field: mcpToolCapabilities)
  # Relationship to ToolSets: represents which tool collections include this tool
  # This is about logical organization and grouping, separate from execution
  toolSets: [ToolSet!] @hasInverse(field: mcpToolCapabilities)
  workspace: Workspace! @hasInverse(field: mcpTools)
  toolCalls: [ToolCall!] @hasInverse(field: mcpTool)
}

# ToolSet: A logical collection of tools for organization purposes
# This type separates the concept of tool GROUPING from tool EXECUTION.
# - ToolSets are about organizing tools into meaningful collections (e.g., "Data Analysis Tools")
# - Runtimes are about execution environments that can run tools
# This separation allows tools to be grouped logically while maintaining flexible execution models.
type ToolSet @withSubscription {
  id: ID!
  name: String! @search(by: [hash])
  description: String
  status: ActiveStatus! @search
  createdAt: DateTime!
  lastSeenAt: DateTime
  # The tools that belong to this collection
  mcpToolCapabilities: [MCPTool!] @hasInverse(field: toolSets)
  workspace: Workspace! @hasInverse(field: toolSets)
}

type Runtime @withSubscription {
  id: ID!
  name: String! @search(by: [hash])
  description: String
  status: ActiveStatus! @search
  roots: String
  createdAt: DateTime!
  processId: String
  hostIP: String
  hostname: String
  mcpClientName: String
  lastSeenAt: DateTime
  capabilities: [String!]
  mcpToolCapabilities: [MCPTool!] @hasInverse(field: runtimes)
  mcpServers: [MCPServer!] @hasInverse(field: runtime)
  workspace: Workspace! @hasInverse(field: runtimes)
  toolCalls: [ToolCall!] @hasInverse(field: calledBy)
  toolResponses: [ToolCall!] @hasInverse(field: executedBy)
}

type User @withSubscription {
  id: ID!
  email: String! @search(by: [hash])
  password: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastLoginAt: DateTime
  failedLoginAttempts: Int
  lockedUntil: DateTime
  adminOfWorkspaces: [Workspace!] @hasInverse(field: admins)
  membersOfWorkspaces: [Workspace!] @hasInverse(field: users)
  sessions: [Session!] @hasInverse(field: user)
}

type Session @withSubscription {
  id: ID!
  refreshToken: String! @search(by: [hash])
  userId: String! @search(by: [hash])
  user: User! @hasInverse(field: sessions)
  deviceInfo: String
  ipAddress: String
  userAgent: String
  createdAt: DateTime!
  expiresAt: DateTime! @search
  lastUsedAt: DateTime
  isActive: Boolean! @search
}

enum OnboardingStepType {
  ONBOARDING
  ANNOUNCEMENT
  LEARNING
}

enum OnboardingStepStatus {
  PENDING
  COMPLETED
  DISMISSED
}

enum ToolCallStatus {
  PENDING
  COMPLETED
  FAILED
}

type OnboardingStep {
  id: ID!
  stepId: String! @search(by: [hash])
  type: OnboardingStepType!
  status: OnboardingStepStatus!
  priority: Int
  createdAt: DateTime!
  updatedAt: DateTime
}

type ToolCall {
  id: ID!
  toolInput: String!
  calledAt: DateTime!
  completedAt: DateTime
  status: ToolCallStatus!
  toolOutput: String
  error: String
  mcpTool: MCPTool! @hasInverse(field: toolCalls)
  calledBy: Runtime! @hasInverse(field: toolCalls)
  executedBy: Runtime @hasInverse(field: toolResponses)
}

enum AIProvider {
  OPENAI
  ANTHROPIC
}

type AIConfig @withSubscription {
  id: ID!
  provider: AIProvider! @search
  model: String!
  encryptedApiKey: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  workspace: Workspace! @hasInverse(field: aiConfig)
}
