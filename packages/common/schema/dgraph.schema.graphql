scalar DateTime

enum ActiveStatus {
  ACTIVE
  INACTIVE
}

enum MCPTransportType {
  STDIO
  SSE
  STREAM
}

enum ExecutionTarget {
  AGENT
  EDGE
}

enum RuntimeType {
  EDGE
  MCP
}

type System @withSubscription {
  id: ID!
  initialized: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  instanceId: String!
  runtimes: [Runtime!] @hasInverse(field: system)
  workspaces: [Workspace!] @hasInverse(field: system)
  defaultWorkspace: Workspace
  admins: [User!]
}

type Workspace @withSubscription {
  id: ID!
  name: String! @search(by: [hash])
  createdAt: DateTime!
  mcpServers: [MCPServer!] @hasInverse(field: workspace)
  mcpTools: [MCPTool!] @hasInverse(field: workspace)
  runtimes: [Runtime!] @hasInverse(field: workspace)
  skills: [Skill!] @hasInverse(field: workspace)
  agents: [Agent!] @hasInverse(field: workspace)
  registryServers: [MCPRegistryServer!] @hasInverse(field: workspace)
  admins: [User!] @hasInverse(field: adminOfWorkspaces)
  users: [User!] @hasInverse(field: membersOfWorkspaces)
  system: System! @hasInverse(field: workspaces)
  onboardingSteps: [OnboardingStep!]
  aiProviders: [AIProviderConfig!] @hasInverse(field: workspace)
  defaultAIModel: String
}

type MCPRegistryServer @withSubscription {
  id: ID!
  name: String! @search(by: [hash])
  description: String!
  title: String!
  repositoryUrl: String!
  version: String!
  packages: String!
  remotes: String
  _meta: String
  createdAt: DateTime!
  lastSeenAt: DateTime!
  workspace: Workspace! @hasInverse(field: registryServers)
  configurations: [MCPServer!] @hasInverse(field: registryServer)
}

type MCPServer @withSubscription {
  id: ID!
  name: String! @search(by: [hash])
  description: String!
  repositoryUrl: String!
  transport: MCPTransportType!
  # The `config` field contains THE SINGLE SELECTED configuration for this MCP server deployment.
  # It is NOT an array - it's the one chosen package or remote configuration.
  #
  # When transport is STDIO: config contains a single Package object following the
  # Package schema from the MCP registry (with identifier, packageArguments, runtimeArguments,
  # environmentVariables, etc.)
  #
  # When transport is SSE or STREAM: config contains a single Transport object following
  # the Transport schema from the MCP registry (with type, url, headers, etc.)
  # Note: SSE and STREAM both use the Transport schema, differentiated by the "type" field
  # ("sse" for SSE transport, "streamableHttp" for STREAM transport)
  #
  # The config values come from selecting ONE item from either MCPRegistryServer.packages
  # or MCPRegistryServer.remotes during the server configuration workflow.
  config: String!
  tools: [MCPTool!] @hasInverse(field: mcpServer)
  runOn: ExecutionTarget @search
  # an MCP server can run either on a specific runtime - or if no value is provided it will be launch on the agent runtime which requires the capability
  runtime: Runtime @hasInverse(field: mcpServers)
  registryServer: MCPRegistryServer! @hasInverse(field: configurations)
  workspace: Workspace! @hasInverse(field: mcpServers)
}

type MCPTool @withSubscription {
  id: ID!
  name: String! @search(by: [hash])
  description: String!
  inputSchema: String!
  annotations: String!
  status: ActiveStatus! @search
  createdAt: DateTime!
  lastSeenAt: DateTime!
  mcpServer: MCPServer! @hasInverse(field: tools)
  # Relationship to Skills: represents which tool collections include this tool
  skills: [Skill!] @hasInverse(field: mcpTools)
  workspace: Workspace! @hasInverse(field: mcpTools)
  toolCalls: [ToolCall!] @hasInverse(field: mcpTool)
}

# Skill: A logical collection of tools for organization purposes
# This type separates the concept of tool GROUPING from tool EXECUTION.
# - Skills are about organizing tools into meaningful collections (e.g., "Data Analysis Tools")
# - Runtimes are about execution environments that can run tools
# This separation allows tools to be grouped logically while maintaining flexible execution models.
type Skill @withSubscription {
  id: ID!
  name: String! @search(by: [hash])
  description: String
  createdAt: DateTime!
  updatedAt: DateTime
  # The tools that belong to this collection
  mcpTools: [MCPTool!] @hasInverse(field: skills)
  # The agents that can use this skill
  agents: [Agent!] @hasInverse(field: skills)
  workspace: Workspace! @hasInverse(field: skills)
  toolCalls: [ToolCall!] @hasInverse(field: calledBy)
}

# Agent: An AI agent with configurable parameters that can execute tasks
# using AI providers and associated skills.
type Agent @withSubscription {
  id: ID!
  name: String! @search(by: [hash])
  description: String
  createdAt: DateTime!
  updatedAt: DateTime
  systemPrompt: String!
  model: String!
  temperature: Float!
  maxTokens: Int!
  # The skills available to this agent
  skills: [Skill!] @hasInverse(field: agents)
  # Where this agent runs - AGENT (on the agent runtime) or EDGE (on a specific edge runtime)
  runOn: ExecutionTarget @search
  # The runtime this agent runs on (only applicable when runOn = EDGE)
  runtime: Runtime @hasInverse(field: agents)
  workspace: Workspace! @hasInverse(field: agents)
}

type Runtime @withSubscription {
  id: ID!
  name: String! @search(by: [hash])
  description: String
  status: ActiveStatus! @search
  type: RuntimeType! @search
  roots: String
  createdAt: DateTime!
  processId: String
  hostIP: String
  hostname: String
  mcpClientName: String
  lastSeenAt: DateTime
  mcpServers: [MCPServer!] @hasInverse(field: runtime)
  agents: [Agent!] @hasInverse(field: runtime)
  workspace: Workspace @hasInverse(field: runtimes)
  system: System @hasInverse(field: runtimes)
  toolResponses: [ToolCall!] @hasInverse(field: executedBy)
}

type User @withSubscription {
  id: ID!
  email: String! @search(by: [hash])
  password: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastLoginAt: DateTime
  failedLoginAttempts: Int
  lockedUntil: DateTime
  adminOfWorkspaces: [Workspace!] @hasInverse(field: admins)
  membersOfWorkspaces: [Workspace!] @hasInverse(field: users)
  sessions: [Session!] @hasInverse(field: user)
}

type Session @withSubscription {
  id: ID!
  refreshToken: String! @search(by: [hash])
  userId: String! @search(by: [hash])
  user: User! @hasInverse(field: sessions)
  deviceInfo: String
  ipAddress: String
  userAgent: String
  createdAt: DateTime!
  expiresAt: DateTime! @search
  lastUsedAt: DateTime
  isActive: Boolean! @search
}

enum OnboardingStepType {
  ONBOARDING
  ANNOUNCEMENT
  LEARNING
}

enum OnboardingStepStatus {
  PENDING
  COMPLETED
  DISMISSED
}

enum ToolCallStatus {
  PENDING
  COMPLETED
  FAILED
}

type OnboardingStep {
  id: ID!
  stepId: String! @search(by: [hash])
  type: OnboardingStepType!
  status: OnboardingStepStatus!
  priority: Int
  metadata: String
  createdAt: DateTime!
  updatedAt: DateTime
}

type ToolCall {
  id: ID!
  toolInput: String!
  calledAt: DateTime!
  completedAt: DateTime
  status: ToolCallStatus!
  toolOutput: String
  error: String
  isTest: Boolean!
  executedByAgent: Boolean
  mcpTool: MCPTool! @hasInverse(field: toolCalls)
  calledBy: Skill @hasInverse(field: toolCalls)
  executedBy: Runtime @hasInverse(field: toolResponses)
}

type IdentityKey @withSubscription {
  id: ID!
  # Workspace Key       WSK_____
  # Runtime Key         RTK_____
  # Skill Key           SKL_____
  key: String! @search(by: [hash]) @id
  relatedId: String! @search(by: [hash])
  createdAt: DateTime!
  expiresAt: DateTime @search
  revokedAt: DateTime @search
  description: String
  permissions: String
}

# AI Provider Configuration - BYOK (Bring Your Own Key) support
enum AIProviderType {
  OPENAI
  ANTHROPIC
  GOOGLE
  OLLAMA
}

type AIProviderConfig @withSubscription {
  id: ID!
  workspace: Workspace! @hasInverse(field: aiProviders)
  provider: AIProviderType! @search
  # Encrypted API key - null for Ollama (local)
  encryptedApiKey: String
  # Custom base URL - required for Ollama, optional for others (proxies, Azure, etc.)
  baseUrl: String
  # Cached list of available models (refreshed on validation)
  availableModels: [String!]
  createdAt: DateTime!
  updatedAt: DateTime!
}
